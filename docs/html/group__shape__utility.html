<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AGL: Shape utility</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AGL
   &#160;<span id="projectnumber">0</span>
   </div>
   <div id="projectbrief">3D graphics library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__shape__utility.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Shape utility</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8c7eb72542e2c287b8f1bea95de7d71d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shape__utility.html#ga8c7eb72542e2c287b8f1bea95de7d71d">normalizeVertices</a> (<a class="el" href="classagl_1_1Entity.html">Entity</a> &amp;e, float t=1)</td></tr>
<tr class="memdesc:ga8c7eb72542e2c287b8f1bea95de7d71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize all vertices of <em>e</em>.  <a href="group__shape__utility.html#ga8c7eb72542e2c287b8f1bea95de7d71d">More...</a><br /></td></tr>
<tr class="separator:ga8c7eb72542e2c287b8f1bea95de7d71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f8f40ae1c70493b5685a42ad9b924ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shape__utility.html#ga6f8f40ae1c70493b5685a42ad9b924ea">subdivideFaces</a> (<a class="el" href="classagl_1_1Entity.html">Entity</a> &amp;e)</td></tr>
<tr class="memdesc:ga6f8f40ae1c70493b5685a42ad9b924ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide all faces of <em>e</em>.  <a href="group__shape__utility.html#ga6f8f40ae1c70493b5685a42ad9b924ea">More...</a><br /></td></tr>
<tr class="separator:ga6f8f40ae1c70493b5685a42ad9b924ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab642ff721f66652d7d53abb8d8b8243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shape__utility.html#gaab642ff721f66652d7d53abb8d8b8243">calcNormals</a> (<a class="el" href="classagl_1_1Entity.html">Entity</a> &amp;e, bool perFace=false)</td></tr>
<tr class="memdesc:gaab642ff721f66652d7d53abb8d8b8243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the normals for the <a class="el" href="classagl_1_1Entity.html" title="The Entity; basically all visible objects in AGL. ">Entity</a> algorithmically.  <a href="group__shape__utility.html#gaab642ff721f66652d7d53abb8d8b8243">More...</a><br /></td></tr>
<tr class="separator:gaab642ff721f66652d7d53abb8d8b8243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bebf5f613edf1b5fc7ccfe5a8c96dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shape__utility.html#ga9bebf5f613edf1b5fc7ccfe5a8c96dcc">calcTextureCoords</a> (<a class="el" href="classagl_1_1Entity.html">Entity</a> &amp;e, glm::vec3 px=glm::vec3(.5, 0,.5), glm::vec3 py=glm::vec3(.5,.5, 0), bool normalize=false)</td></tr>
<tr class="memdesc:ga9bebf5f613edf1b5fc7ccfe5a8c96dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates texture coordinates for the <a class="el" href="classagl_1_1Entity.html" title="The Entity; basically all visible objects in AGL. ">Entity</a> algorithmically.  <a href="group__shape__utility.html#ga9bebf5f613edf1b5fc7ccfe5a8c96dcc">More...</a><br /></td></tr>
<tr class="separator:ga9bebf5f613edf1b5fc7ccfe5a8c96dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacce8ac512e6bfa38efd149c865139b2a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; GLuint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shape__utility.html#gacce8ac512e6bfa38efd149c865139b2a">triangulatePolygon</a> (const std::vector&lt; GLuint &gt; &amp;polygon)</td></tr>
<tr class="memdesc:gacce8ac512e6bfa38efd149c865139b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates polygons with 3+ vertices.  <a href="group__shape__utility.html#gacce8ac512e6bfa38efd149c865139b2a">More...</a><br /></td></tr>
<tr class="separator:gacce8ac512e6bfa38efd149c865139b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These are utility functions that can be used on <a class="el" href="classagl_1_1Entity.html" title="The Entity; basically all visible objects in AGL. ">Entity</a> or the <a class="el" href="group__shapes.html">shapes</a>. These functions will modify the <a class="el" href="classagl_1_1Entity.html" title="The Entity; basically all visible objects in AGL. ">Entity</a> they take in as parameter instead of returning a new <a class="el" href="classagl_1_1Entity.html" title="The Entity; basically all visible objects in AGL. ">Entity</a>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaab642ff721f66652d7d53abb8d8b8243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab642ff721f66652d7d53abb8d8b8243">&#9670;&nbsp;</a></span>calcNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calcNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagl_1_1Entity.html">Entity</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perFace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the normals for the <a class="el" href="classagl_1_1Entity.html" title="The Entity; basically all visible objects in AGL. ">Entity</a> algorithmically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td><a class="el" href="classagl_1_1Entity.html" title="The Entity; basically all visible objects in AGL. ">Entity</a> to calculate the normals for. </td></tr>
    <tr><td class="paramname">perFace</td><td>If <code>true</code>, normals are calculated for each face, instead of each vertex. <b>Currently unused.</b></td></tr>
  </table>
  </dd>
</dl>
<p>This function calculates the normals for each vertex of <em>e</em>. The normals are pointed radially outwards from the geometric center of the entity. Geometric center is calculated simply by averaging all the vertices. </p>

</div>
</div>
<a id="ga9bebf5f613edf1b5fc7ccfe5a8c96dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bebf5f613edf1b5fc7ccfe5a8c96dcc">&#9670;&nbsp;</a></span>calcTextureCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calcTextureCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagl_1_1Entity.html">Entity</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>px</em> = <code>glm::vec3(.5,&#160;0,.5)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>py</em> = <code>glm::vec3(.5,.5,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates texture coordinates for the <a class="el" href="classagl_1_1Entity.html" title="The Entity; basically all visible objects in AGL. ">Entity</a> algorithmically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td><a class="el" href="classagl_1_1Entity.html" title="The Entity; basically all visible objects in AGL. ">Entity</a> to calculate the <a class="el" href="classagl_1_1Entity.html#a176367e5561156785a5cf8942819c127" title="Texture coordinates. ">Entity::uvs</a> for. </td></tr>
    <tr><td class="paramname">px</td><td>Parameter for x coordinate of texture. </td></tr>
    <tr><td class="paramname">py</td><td>Parameter for y coordinate of texture. </td></tr>
    <tr><td class="paramname">normalize</td><td>If <code>true</code>, the coordinates are scaled to range from 0 to 1.</td></tr>
  </table>
  </dd>
</dl>
<p>This function calculates the texture coordinates for <em>e</em> automatically. The coordinates may not be what you expect, but are promissed to be continuous. The coordinate for each vertex is generated by calculating the dot product of the vertex with the respective parameter. The default parameters works almost well to generate non-repetative and smooth coordinates for vertices ranging between 0 to 1. </p>

</div>
</div>
<a id="ga8c7eb72542e2c287b8f1bea95de7d71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c7eb72542e2c287b8f1bea95de7d71d">&#9670;&nbsp;</a></span>normalizeVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalizeVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagl_1_1Entity.html">Entity</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize all vertices of <em>e</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td><a class="el" href="classagl_1_1Entity.html" title="The Entity; basically all visible objects in AGL. ">Entity</a> to normalize vertices. </td></tr>
    <tr><td class="paramname">t</td><td>Amount of normalization.</td></tr>
  </table>
  </dd>
</dl>
<p>This function normalizes all the vertices of an <a class="el" href="classagl_1_1Entity.html" title="The Entity; basically all visible objects in AGL. ">Entity</a>, it projects all the vertices on the surface of a unit sphere centered at the origin. The value of <em>t</em> defines the amount of normalization. 0 means no normalization, ie. the vertices will remain at their original position. 1 means complete normalization, ie. the vertices will be completely mapped on the surface of a unit sphere. For example, a value of 0.5 will bring all the vertices halfways to the surface of a unit sphere. </p>

</div>
</div>
<a id="ga6f8f40ae1c70493b5685a42ad9b924ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f8f40ae1c70493b5685a42ad9b924ea">&#9670;&nbsp;</a></span>subdivideFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void subdivideFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagl_1_1Entity.html">Entity</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subdivide all faces of <em>e</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The entity whose faces will be normalized.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will insert a new vertex at the center of each of the edges of the entity. It'll then join the three vertices at the center of each of the edges of each of the triangular faces, thereby dividing each face into four face. This way more vertex and faces are introduced, which can later be modified for a smoother surface. </p>

</div>
</div>
<a id="gacce8ac512e6bfa38efd149c865139b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacce8ac512e6bfa38efd149c865139b2a">&#9670;&nbsp;</a></span>triangulatePolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; GLuint &gt; triangulatePolygon </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; GLuint &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangulates polygons with 3+ vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>Indices to triangulate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new set of indices such that all triplets represents a valid triangle.</dd></dl>
<p>This function is used to triangulate non-triangular faces. This is different from a normal <a href="https://en.wikipedia.org/wiki/Polygon_triangulation">triangulation algorithm</a>. This function do not require the actual vertices as it does not introduce new vertices. It just rearranges and copies the indices forming the faces (polygons) such that each trplet represents a non-overlapping triangle. This also means that this algorithm will fail for non-convex polygons. The algorithm tries to equally distribute the vertices among different faces to reduce crowding of edges. It also preserves the orientation of the face vertices in the new triangular faces. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
